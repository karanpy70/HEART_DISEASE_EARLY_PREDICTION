import pandas as pd
import numpy as np
import joblib
import os
import matplotlib.pyplot as plt
import seaborn as sns

# TensorFlow / Keras (Needed for loading the saved CNN model)
import tensorflow as tf
from tensorflow.keras.models import load_model

# Scikit-learn
from sklearn.model_selection import train_test_split
from sklearn.impute import SimpleImputer
from sklearn.metrics import accuracy_score, confusion_matrix

class HeartDiseaseDataPipeline:
    def __init__(self, csv_path):
        self.csv_path = csv_path
        # Paths to the model files generated by train_model.py
        self.MODEL_PATH = "heart_disease_model.keras"
        self.PREPROCESSOR_PATH = "preprocessor.pkl"
        self.df = None

    def load_and_clean_data(self):
        """Loads data and returns True if successful, False otherwise."""
        print("1. Loading and Cleaning Data...")
        try:
            df = pd.read_csv(self.csv_path)
        except FileNotFoundError:
            print(f"ERROR: CSV file not found at: {self.csv_path}")
            return False

        if 'Patient_Name' in df.columns:
            df = df.drop(columns=['Patient_Name'])
            
        # Median Imputation for physiological zero values
        df['resting bp s'] = df['resting bp s'].replace(0, np.nan)
        df['cholesterol'] = df['cholesterol'].replace(0, np.nan)
        
        imputer = SimpleImputer(strategy='median')
        df['resting bp s'] = imputer.fit(df[['resting bp s']]).transform(df[['resting bp s']])
        df['cholesterol'] = imputer.fit(df[['cholesterol']]).transform(df[['cholesterol']])
        
        self.df = df
        print("Data loaded and cleaned successfully.")
        return True

    def _plot_all_results(self, model_ready, accuracy, cm):
        """Generates all four visualizations in a single view (Subplots)."""
        print("\n4. Generating All 4 Visualizations (Single Page)...")
        plt.style.use('seaborn-v0_8-whitegrid')
        
        # Create a figure with 2 rows and 2 columns
        fig, axes = plt.subplots(2, 2, figsize=(18, 14)) # Slightly larger size for 4 plots
        fig.suptitle('Comprehensive Cardiac Data Analysis Overview', fontsize=18, weight='bold')

        # --- Graph 1: Age Distribution (Top Left) ---
        # This shows how heart disease prevalence changes across different ages.
        sns.histplot(data=self.df, x='age', hue='target', kde=True, palette='viridis', ax=axes[0, 0])
        axes[0, 0].set_title('1. Age Distribution & Heart Disease')
        axes[0, 0].set_xlabel('Age')
        
        # --- Graph 2: Cholesterol Levels (Top Right) ---
        # This shows the range of cholesterol (mg/dL) for patients with and without heart disease.
        sns.boxplot(x='target', y='cholesterol', data=self.df, palette='Set2', ax=axes[0, 1])
        axes[0, 1].set_title('2. Cholesterol Levels by Status')
        axes[0, 1].set_xlabel('Heart Disease (0=No, 1=Yes)')
        axes[0, 1].set_ylabel('Cholesterol (mg/dL)')
        
        # --- Graph 3: Max Heart Rate (Bottom Left) ---
        # This shows the relationship between maximum heart rate and exercise-induced chest pain.
        sns.violinplot(x='exercise angina', y='max heart rate', hue='target', data=self.df, split=True, palette='coolwarm', ax=axes[1, 0])
        axes[1, 0].set_title('3. Max Heart Rate vs. Angina')
        axes[1, 0].set_xlabel('Exercise Angina (0=No, 1=Yes)')
        axes[1, 0].set_ylabel('Max Heart Rate (bpm)')

        # --- Graph 4: Confusion Matrix (Bottom Right) ---
        ax_cm = axes[1, 1]
        if model_ready and cm is not None and accuracy is not None:
            # The Confusion Matrix visualizes the performance of the trained CNN model.
            sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', ax=ax_cm, 
                        cbar=False, linewidths=.5, linecolor='black',
                        yticklabels=['Actual: No Disease', 'Actual: Disease'],
                        xticklabels=['Pred: No Disease', 'Pred: Disease'])
            ax_cm.set_title(f'4. CNN Confusion Matrix (Acc: {accuracy*100:.2f}%)')
            ax_cm.set_ylabel('Actual Label')
            ax_cm.set_xlabel('Predicted Label')
        else:
            # If model isn't ready, show a message instead of the matrix
            ax_cm.text(0.5, 0.5, "Model/Preprocessor Missing.\nRun 'train_model.py' first.", 
                       horizontalalignment='center', verticalalignment='center', 
                       fontsize=14, color='red', transform=ax_cm.transAxes)
            ax_cm.set_title('4. Model Evaluation Status')
            ax_cm.axis('off') # Hide axes for the message

        plt.tight_layout(rect=[0, 0.03, 1, 0.95]) # Adjust layout for suptitle
        plt.show()

    def train_and_evaluate(self):
        """Loads saved model, evaluates its performance, and plots all 4 visualizations."""
        if self.df is None:
            print("Data not loaded. Cannot evaluate model.")
            return

        print("\n3. Loading Saved Model and Evaluating Test Accuracy...")
        model_ready = False
        accuracy = None
        cm = None
        
        # --- Load Resources ---
        try:
            model = load_model(self.MODEL_PATH)
            preprocessor = joblib.load(self.PREPROCESSOR_PATH)
            model_ready = True
        except Exception as e:
            print(f"ERROR: Could not load model files. Did you run 'train_model.py'?\nError: {e}")

        if model_ready:
            # --- Prepare Test Data ---
            X = self.df.drop(columns=['target'])
            y = self.df['target']
            
            # Use the same split parameters as training
            X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.15, random_state=42, stratify=y)
            
            # --- Preprocess Test Data ---
            try:
                X_processed = preprocessor.transform(X_test)
                # Reshape for CNN
                X_test_cnn = X_processed.reshape(X_processed.shape[0], X_processed.shape[1], 1)
                
                # --- Evaluate ---
                _, accuracy = model.evaluate(X_test_cnn, y_test, verbose=0)
                
                print(f"\nModel Test Accuracy: {accuracy*100:.2f}%")
                print(f"Evaluated on {len(X_test)} test samples.")
                
                # --- Calculate Confusion Matrix ---
                y_pred_prob = model.predict(X_test_cnn, verbose=0)
                y_pred = (y_pred_prob > 0.5).astype(int)
                cm = confusion_matrix(y_test, y_pred)
            except Exception as e:
                print(f"Error during evaluation: {e}")
                model_ready = False

        self._plot_all_results(model_ready, accuracy, cm)